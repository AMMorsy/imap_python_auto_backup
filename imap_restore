#!/usr/bin/env python3
"""
Email Restore Tool - Search and restore emails from mbox backups
"""

import mailbox
import os
import sys
import imaplib
import email
from datetime import datetime
from email.utils import parsedate_to_datetime

# Configuration
BACKUP_DIR = "type/your/path/to/backup/folder"
IMAP_SERVER = "imap.host.com"
IMAP_PORT = 993
EMAIL_ADDRESS = "type_your_email"
EMAIL_PASSWORD = "type_your_email_password"

def list_backup_files():
    """List all available backup files"""
    backups = []
    for filename in sorted(os.listdir(BACKUP_DIR)):
        if filename.endswith('.mbox'):
            filepath = os.path.join(BACKUP_DIR, filename)
            size = os.path.getsize(filepath) / (1024*1024)  # MB
            mtime = datetime.fromtimestamp(os.path.getmtime(filepath))
            backups.append({
                'filename': filename,
                'path': filepath,
                'size_mb': size,
                'date': mtime
            })
    return backups

def search_emails(mbox_file, search_term=None, from_addr=None, subject=None, date_from=None):
    """Search for emails in an mbox file"""
    try:
        mbox = mailbox.mbox(mbox_file)
        results = []
        
        for i, message in enumerate(mbox):
            match = True
            
            # Search in subject
            if subject and subject.lower() not in str(message.get('subject', '')).lower():
                match = False
            
            # Search in from address
            if from_addr and from_addr.lower() not in str(message.get('from', '')).lower():
                match = False
            
            # Search in body
            if search_term:
                body = ""
                if message.is_multipart():
                    for part in message.walk():
                        if part.get_content_type() == "text/plain":
                            try:
                                body += part.get_payload(decode=True).decode('utf-8', errors='ignore')
                            except:
                                pass
                else:
                    try:
                        body = message.get_payload(decode=True).decode('utf-8', errors='ignore')
                    except:
                        body = ""
                
                if search_term.lower() not in body.lower() and \
                   search_term.lower() not in str(message.get('subject', '')).lower():
                    match = False
            
            # Date filter
            if date_from and message.get('date'):
                try:
                    msg_date = parsedate_to_datetime(message.get('date'))
                    if msg_date < date_from:
                        match = False
                except:
                    pass
            
            if match:
                results.append({
                    'index': i,
                    'message': message,
                    'subject': message.get('subject', 'No Subject'),
                    'from': message.get('from', 'Unknown'),
                    'date': message.get('date', 'Unknown'),
                    'message_id': message.get('message-id', '')
                })
        
        mbox.close()
        return results
    
    except Exception as e:
        print(f"Error searching mbox: {str(e)}")
        return []

def display_results(results):
    """Display search results"""
    if not results:
        print("\nNo emails found matching your criteria.")
        return
    
    print(f"\nFound {len(results)} email(s):")
    print("=" * 80)
    for i, result in enumerate(results, 1):
        print(f"\n[{i}] Subject: {result['subject']}")
        print(f"    From: {result['from']}")
        print(f"    Date: {result['date']}")
        print(f"    Message-ID: {result['message_id']}")
    print("\n" + "=" * 80)

def save_email_to_file(message, output_file):
    """Save an email message to an .eml file"""
    try:
        with open(output_file, 'wb') as f:
            f.write(message.as_bytes())
        print(f"\nEmail saved to: {output_file}")
        print("You can open this file with any email client (Thunderbird, Outlook, etc.)")
        return True
    except Exception as e:
        print(f"Error saving email: {str(e)}")
        return False

def restore_to_imap(message, folder="INBOX"):
    """Restore email back to IMAP server"""
    try:
        print(f"\nConnecting to {IMAP_SERVER}...")
        mail = imaplib.IMAP4_SSL(IMAP_SERVER, IMAP_PORT)
        mail.login(EMAIL_ADDRESS, EMAIL_PASSWORD)
        
        # Get the original date from the email or use current time
        date_str = message.get('date')
        if date_str:
            try:
                msg_date = parsedate_to_datetime(date_str)
            except:
                msg_date = datetime.now()
        else:
            msg_date = datetime.now()
        
        # Append message to folder
        # Use None for flags and let the server handle the date
        mail.append(folder, None, None, message.as_bytes())
        mail.logout()
        
        print(f"Email restored to {folder} successfully!")
        return True
    except Exception as e:
        print(f"Error restoring to IMAP: {str(e)}")
        return False

def interactive_search():
    """Interactive search interface"""
    print("\n" + "=" * 80)
    print("EMAIL RESTORE TOOL")
    print("=" * 80)
    
    # List available backups
    backups = list_backup_files()
    if not backups:
        print("\nNo backup files found in", BACKUP_DIR)
        return
    
    print("\nAvailable backup files:")
    for i, backup in enumerate(backups, 1):
        print(f"[{i}] {backup['filename']} - {backup['size_mb']:.2f} MB - {backup['date'].strftime('%Y-%m-%d %H:%M')}")
    
    # Select backup file
    try:
        choice = int(input(f"\nSelect backup file (1-{len(backups)}): "))
        if choice < 1 or choice > len(backups):
            print("Invalid choice")
            return
        selected_backup = backups[choice - 1]
    except ValueError:
        print("Invalid input")
        return
    
    print(f"\nSearching in: {selected_backup['filename']}")
    
    # Get search criteria
    print("\nEnter search criteria (press Enter to skip):")
    subject = input("Subject contains: ").strip()
    from_addr = input("From address contains: ").strip()
    search_term = input("Body/Subject contains: ").strip()
    
    # Search
    print("\nSearching...")
    results = search_emails(
        selected_backup['path'],
        search_term=search_term if search_term else None,
        from_addr=from_addr if from_addr else None,
        subject=subject if subject else None
    )
    
    display_results(results)
    
    if not results:
        return
    
    # Select email to restore
    try:
        choice = input(f"\nSelect email to restore (1-{len(results)}) or 'q' to quit: ").strip()
        if choice.lower() == 'q':
            return
        
        choice = int(choice)
        if choice < 1 or choice > len(results):
            print("Invalid choice")
            return
        
        selected_email = results[choice - 1]['message']
    except ValueError:
        print("Invalid input")
        return
    
    # Restore options
    print("\nRestore options:")
    print("[1] Save to .eml file (open with email client)")
    print("[2] Restore directly to IMAP server")
    print("[3] View full email content")
    
    action = input("\nSelect action (1-3): ").strip()
    
    if action == '1':
        output_file = input("Enter output filename (e.g., recovered_email.eml): ").strip()
        if not output_file.endswith('.eml'):
            output_file += '.eml'
        save_email_to_file(selected_email, output_file)
    
    elif action == '2':
        folder = input("Enter destination folder (default: INBOX): ").strip() or "INBOX"
        restore_to_imap(selected_email, folder)
    
    elif action == '3':
        print("\n" + "=" * 80)
        print(selected_email.as_string())
        print("=" * 80)
    
    else:
        print("Invalid action")

if __name__ == "__main__":
    interactive_search()
